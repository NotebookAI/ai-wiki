---
id: tool-calling
title: 工具调用
title_en: Tool Calling · Function Calling
category: model
type: concept
order: 81
aliases: [Function Calling, Tool Calling, 函数调用]
keywords: [Tool Calling, Function Calling, 工具使用, Agent, JSON Schema, 结构化输出]
brief: 让模型以“结构化参数”触发外部工具/函数的能力，用来把 LLM 从纯文本生成扩展为可执行的动作与工作流。
meta: [Agent 基础, 结构化交互]
---

工具调用（Tool Calling / Function Calling）指的是：模型在对话中不只输出自然语言，还可以输出一段可被程序可靠解析的结构化数据（常见为 JSON），以触发某个外部函数/工具执行，并把执行结果再回传给模型继续推理。

你可以把它看成一种“**把自然语言意图映射为可执行 API 调用**”的机制，常见于智能体（Agent）、自动化工作流、AI 搜索、代码助手等系统。

### 为什么重要
- **可控性更强**：相比让模型“自己写一段伪代码”，结构化调用更容易做校验、权限控制与审计。
- **能力可扩展**：模型本身不需要内置所有知识与能力，通过工具就能访问最新数据与执行动作。

### 核心组成
- **工具定义**：描述工具名称、用途、参数（常用 JSON Schema 表达）、返回字段等。
- **调用生成**：模型选择工具并生成参数。
- **执行与回传**：宿主程序执行工具，把结果作为“工具消息/函数结果”再喂回模型。

### 容易踩坑的点
- **幻觉调用**：模型可能调用不存在的工具或拼错参数；需要严格校验与错误回传。
- **注入攻击**：来自网页/文档/用户的内容可能诱导模型越权调用工具；需要权限分层、上下文隔离与策略约束（见 {{ '/terms/prompt-injection/' | relative_url }} 与 {{ '/terms/guardrails/' | relative_url }}）。
- **非确定性**：同一意图可能出现不同调用形式；建议用“结构化输出/约束解码”提高一致性。

### 典型用法
- 访问知识库/检索：先检索再生成（常见于 RAG）。
- 查询业务系统：如 CRM/工单/库存系统的只读查询与写入操作。
- 规划与执行：先让模型产出计划，再逐步调用工具执行并校验结果。
